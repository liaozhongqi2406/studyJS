# 前端知识汇总

## 1. JS语法

### 1.1 数据类型

在JS中一共有六种数据类型 ：

String Number Boolean Null Undefined属于基本数据类型

Object属于引用数据类型

- String 字符串

  在JS中字符串需要使用引号引起来、使用双引号或单引号都可以，但是不要混着用、引号不能嵌套，双引号不能放双引号，单引号不能放单引号

  在字符串中我们可以使用\作为转义字符 、当表示一些特殊符号时可以使用\进行转义

  ```
  \" 表示 "
  \' 表示 '
  \n 表示换行
  \t 制表符
  \\ 表示\	
  ```

  将其他数据类型转为String有两种方法：

  方式一：调用被转换数据类型的toString()方法  该方法不会影响到原变量，它会将转换的结果返回  注意： null和undefined这两个值没有toString()方法 调用他们的方法，会报错

  方式二：  调用String()函数，并将被转换的数据作为参数传递给函数 对于Number和Boolean实际上就是调用的toString()方法 对于null和undefined，就不会调用toString()方法  它会将 null 直接转换为 "null" 将 undefined 直接转换为 "undefined"

- Number 

  在JS中所有的数值都是Number类型，包括整数和浮点数（小数）

  JS中可以表示的数字的最大值  Number.MAX_VALUE：1.7976931348623157e+308

     												Number.MIN_VALUE 大于0的最小值 5e-324

  如果使用Number表示的数字超过了最大值，则会返回一个 Infinity 表示正无穷 

  -Infinity 表示负无穷   使用typeof检查 Infinity也会返回number

   NaN 是一个特殊的数字，表示Not A Number  使用typeof检查一个NaN也会返回number

  变量检查：typeof  语法：typeof 变量

  检查字符串时，会返回string 检查数值时，会返回number

  其他的数据类型转换为Number 两种方式：

  转换方式一：使用Number()函数 

  1. 如果是纯数字的字符串，则直接将其转换为数字

  2. 如果字符串中有非数字的内容，则转换为NaN
  3. 如果字符串是一个空串或者是一个全是空格的字符串，则转换为0
  4.  null --> 数字   0  undefined --> 数字 NaN

  转换方式二： parseInt() 把一个字符串转换为一个整数  parseFloat() 把一个字符串转换为一个浮点数

  parseInt()可以将一个字符串中的有效的整数内容去出来，比较适合转换

- Boolean 布尔值 

  布尔值只有两个 true|false  使用typeof检查一个布尔值时，会返回boolean

- NULL和Undefined

   Null（空值）类型的值只有一个，就是null 

  null这个值专门用来表示一个为空的对象、使用typeof检查一个null值时，会返回object

  Undefined（未定义）类型的值只有一个，就undefind 当声明一个变量，但是并不给变量赋值时，它的值就是undefined 使用typeof检查一个undefined时也会返回undefined

### 1.2 运算符

- 相等运算符

  使用 == 来做相等运算  如果值的类型不同， 会自动进行类型转换，将其转换为相同的类型 然后在比较  != 也会对变量进行自动的类型转换

  === 全等 运算符 用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换  如果两个值的类型不同，直接返回false

- 判断

  

### 1.3 对象

对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。

- 对象的分类：

1. 内建对象：由ES标准中定义的对象，在任何的ES的实现中都可以使用 比如：Math String Number Boolean Function Object....
2. 宿主对象  由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象  比如 BOM DOM
3. 自定义对象  由开发人员自己创建的对象

- 对象创建：

1. 使用new关键字创建，使用typeof检查一个对象时，会返回object

2. 使用工厂函数创建对象，

   ```
   /*
   * 使用工厂方法创建对象
   * 	通过该方法可以大批量的创建对象
   */
   function createPerson(name , age ,gender){
   //创建一个新的对象 
       var obj = new Object();
       //向对象中添加属性
       obj.name = name;
       obj.age = age;
       obj.gender = gender;
       obj.sayName = function(){
      		alert(this.name);
   	};
   //将新的对象返回
   	return obj;
   }
   ```

   使用工厂方法创建的对象，使用的构造函数都是Object，创建的对象都是Object这个类型，就导致我们无法区分出多种不同类型的对象

3. 使用对象字面量模式创建对象 {} 同时指定属性/方法

- 对象存储：

  基本数据类型的值直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量

  对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响

- 枚举对象的属性：

  使用for ... in 语句 

  ```
  for(var n in obj){
      console.log("属性名:"+n);
      console.log("属性值:"+obj[n]);
  }
  ```

- 对象的垃圾回收

  JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，我们不需要也不能进行垃圾回收的操作， 我们需要做的只是要将不再使用的对象设置null即可

### 1.4 函数

- 函数也是一个对象，函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码），函数中可以保存一些代码在需要的时候调用，使用typeof检查一个函数对象时，会返回function

- 函数也可以通过构造函数来创建，实际开发中很少会这样做，大部分情况下通过函数声明来进行创建

  //var fun = new Function("console.log('Hello 这是我的第一个函数');");

- 函数的参数

  实参指调用是传入的参数，形参指定义函数是的参数

  调用函数时解析器不会检查实参的类型, 也不会检查实参的数量 

  多余的实参不会被赋值，如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

- 函数对象()

  立即执行函数,函数定义完，立即被调用，这种函数叫做立即执行函数 ：

  ```
  (function(a,b){
      console.log("a = "+a);
      console.log("b = "+b);
  })(123,456);
  ```

- this

  解析器在调用函数每次都会向函数内部传递进一个隐含的参数,  这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象

  1. 以函数的形式调用时，this永远都是window
  2. 以方法的形式调用时，this就是调用方法的那个对象
  3. 当以构造函数的形式调用时，this就是新创建的那个对象
  4. 使用call和apply调用时，this是指定的那个对象

- 构造函数

  构造函数就是一个普通的函数，创建方式和普通函数没有区别, 不同的是构造函数习惯上首字母大写

  普通函数是直接调用，而构造函数需要使用new关键字来调用

  构造函数的执行流程：

  1. 立刻创建一个新的对象
  2. 将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
  3. 逐行执行函数中的代码、
  4. 将新建的对象作为返回值返回

  使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。我们将通过一个构造函数创建的对象，称为是该类的实例

- call() 和 apply()

  这两个方法都是函数对象的方法，需要通过函数对象来调用,在调用call()和apply()可以将一个对象指定为第一个参数,此时这个对象将会成为函数执行时的this 

  call()方法可以将实参在对象之后依次传递

  apply()方法需要将实参封装到一个数组中统一传递

- 在调用函数时，浏览器每次都会传递进两个隐含的参数： 1.函数的上下文对象 this

  2.封装实参的对象 arguments

  在调用函数时，我们所传递的实参都会在arguments中保存,我们即使不定义形参，也可以通过arguments来使用实参，

### 1.5 作用域

-  作用域指一个变量的作用的范围，在JS中一共有两种作用域：

1. 全局作用域

   直接编写在script标签中的JS代码，都在全局作用域，全局作用域在页面打开时创建，在页面关闭时销毁，在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用

   在全局作用域中：创建的变量都会作为window对象的属性保存 创建的函数都会作为window对象的方法保存

   全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到

2. 函数作用域

   调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁，每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的，在函数作用域中可以访问到全局作用域的变量，在全局作用域中无法访问到函数作用域的变量。

   当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找，直到找到全局作用域，如果全局作用域中依然没有找到，则会报错ReferenceError

   在函数中要访问全局变量可以使用window对象

### 1.6 原型 prototype

- 我们所创建的每一个函数，解析器都会向函数中添加一个特别的属性prototype（显示原型属性）, 这个属性对应着一个对象，这个对象就是我们所谓的原型对象， 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的公共内容，统一设置到原型对象中。
- 我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中， 这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了
- 如果函数作为普通函数调用prototype没有任何作用，当函数以构造函数的形式调用时，它所创建的实例对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过__proto__来访问该属性

-   显式原型与隐式原型的关系
  - 函数的prototype: 定义函数时被自动赋值, 值默认为空Object对象, 即为原型对象，原型对象中有一个属性constructor指向函数
  - 对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值
  - 程序员能直接操作显式原型对象, 但不能直接操作隐式原型(ES6之前)

- 原型链

  访问一个对象的属性或方法时时：

  - 先在自身属性中查找，找到就返回
  - 如果没有, 再沿着__proto__这条链向上查找, 找到返回
  - 如果最终没找到, 返回undefined
  - 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作

![image-20210905104146176](.\images\image-20210905104146176.png)

- 函数原型链的注意事项：

1.  函数的显示原型指向的对象默认是空Object实例对象(但Object不满足 里面我们定义了一些共有的方法)
2. 所有函数都是Function的实例(包含Function)
3. Object的原型对象是原型链尽头

- 原型链继承

  1. 套路
     1. 定义父类型构造函数
     2. 给父类型的原型添加方法、
     3. 定义子类型的构造函数
     4. 创建父类型的对象赋值给子类型的原型
     5. 将子类型原型的构造属性设置为子类型
     6. 给子类型原型添加方法
     7.  创建子类型的对象: 可以调用父类型的方法

  2. 关键： 子类型的原型为父类型的一个实例对象

- 借用构造函数继承

  1. 套路：
     1. 定义父类型构造函数
     2. 定义子类型构造函数
     3. 在子类型构造函数中调用父类型构造

  2. 关键:  在子类型构造函数中通用call()调用父类型构造函数

- 组合继承

  - 原型链+借用构造函数的组合继承

  ```
  <script type="text/javascript">
    function Person(name, age) {
      this.name = name
      this.age = age
    }
    Person.prototype.setName = function (name) {
      this.name = name
    }
  
    function Student(name, age, price) {
      Person.call(this, name, age)  // 为了得到属性
      this.price = price
    }
    Student.prototype = new Person() // 为了能看到父类型的方法
    Student.prototype.constructor = Student //修正constructor属性
    Student.prototype.setPrice = function (price) {
      this.price = price
    }
  
    var s = new Student('Tom', 24, 15000)
    s.setName('Bob')
    s.setPrice(16000)
    console.log(s.name, s.age, s.price)
  
  </script>
  ```

- 使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true，可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性 ，使用该方法只有当对象自身中含有属性时，才会返回true

- instanceof是如何判断的?

  表达式: A instanceof B    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false

### 1.7  执行上下文和执行上下文栈

- 变量提升和函数提升

  变量声明提升：通过var定义(声明)的变量, 在定义语句之前就可以访问到 值: undefined

  函数声明提升：通过function声明的函数, 在之前就可以直接调用 值: 函数定义(对象)

- 全局执行上下文

  在执行全局代码前将window确定为全局执行上下文

  对全局数据进行预处理

  - var定义的全局变量==>undefined, 添加为window的属性

  - function声明的全局函数==>赋值(fun), 添加为window的方法
  - this==>赋值(window)

  开始执行全局代码

- 函数执行上下文

  在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象(虚拟的, 存在于栈中)

  对局部数据进行预处理：

  - 形参变量==>赋值(实参)==>添加为执行上下文的属性
  - arguments==>赋值(实参列表), 添加为执行上下文的属性
  -  var定义的局部变量==>undefined, 添加为执行上下文的属性
  - function声明的函数 ==>赋值(fun), 添加为执行上下文的方法
  - this==>赋值(调用函数的对象)

  开始执行函数体代码

- 执行上下文栈
  1. 在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象
  2. 在全局执行上下文(window)确定后, 将其添加到栈中(压栈)
  3. 在函数执行上下文创建后, 将其添加到栈中(压栈)
  4. 在当前函数执行完后,将栈顶的对象移除(出栈)
  5. 当所有的代码执行完后, 栈中只剩下window

### 1.8 闭包

- 理解：
  - 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  - 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性

- 作用：
  - 使用函数内部的变量在函数执行完后, 仍然存活在内存中（延长了局部变量的生命周期）
  - 让函数外部可以操作（读写）到函数内部的数据

- 闭包的生命周期
  1. 产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
  2. 死亡：在嵌套的内部函数成为垃圾对象时消亡

- 写一个闭包程序

  ```
  function fun1() {
  	var a =2;
  	function fn2() }{
  		a++;
  		console.log(a);
  	}
  	return fn2;
  }
  var f = fun1();
  f();
  f();
  ```

- 闭包的应用：
  - 模块化：封装一些数据以及操作数据的函数，向外暴露一些行为
  - 循环遍历监听
  - JS框架大量使用到了闭包

- 缺点：
  - 变量占用内存的事件过长
  - 可能导致内存泄漏
  - 解决：
    - 即使释放 f = null; // 让内部函数对象成为垃圾对象

### 1.9 数组

- 数组也是一个对象，不同的是普通对象是使用字符串作为属性名的，而数组时使用数字来作为索引操作元素
- 数组的创建

1. 构造函数创建 var arr = new Array();
2. 使用字面量创建数组时，可以在创建时就指定数组中的元素  var arr = [1,2,3,4,5,10];

- 数组的方法

  ```
  //创建一个数组
  var arr = ["孙悟空","猪八戒","沙和尚"];
  
  /*
  * push()
  * 	- 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度
  * 	- 可以将要添加的元素作为方法的参数传递，
  * 		这样这些元素将会自动添加到数组的末尾
  * 	- 该方法会将数组新的长度作为返回值返回
  */
  
  var result = arr.push("唐僧","蜘蛛精","白骨精","玉兔精");
  
  
  //console.log(arr);
  //console.log("result = "+result);
  
  /*
  * pop()
  * 	- 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回
  */
  result = arr.pop();
  /*console.log(arr);
  console.log("result = "+result);*/
  
  /*
  * unshift()
  * 	- 向数组开头添加一个或多个元素，并返回新的数组长度
  * 	- 向前边插入元素以后，其他的元素索引会依次调整
  */
  //console.log(arr);
  
  arr.unshift("牛魔王","二郎神");
  
  console.log(arr);
  
  /*
  * shift()
  * 	- 可以删除数组的第一个元素，并将被删除的元素作为返回值返回
  */
  result = arr.shift();
  result = arr.shift();
  
  console.log(arr);
  console.log("result = "+result);
  
  // 数组的遍历
  for(var i=0 ; i<arr.length ; i++){
  				console.log(arr[i]);
  }
  /*
  * forEach()方法需要一个函数作为参数
  * 	- 像这种函数，由我们创建但是不由我们调用的，我们称为回调函数
  * 	- 数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素
  * 		以实参的形式传递进来，我们可以来定义形参，来读取这些内容
  * 	- 浏览器会在回调函数中传递三个参数：
  * 		第一个参数，就是当前正在遍历的元素
  * 		第二个参数，就是当前正在遍历的元素的索引
  * 		第三个参数，就是正在遍历的数组
  * 		
  */
  arr.forEach(function(value , index , obj){
  	console.log(value);
  });
  
  /*
  * slice()
  * 	- 可以用来从数组提取指定元素
  * 	- 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回
  * 	- 参数：
  * 		1.截取开始的位置的索引,包含开始索引
  * 		2.截取结束的位置的索引,不包含结束索引
  * 			- 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素
  * 		- 索引可以传递一个负值，如果传递一个负值，则从后往前计算
  * 			-1 倒数第一个
  * 			-2 倒数第二个
  */
  
  var result = arr.slice(1,4);
  
  result = arr.slice(3);
  
  result = arr.slice(1,-2);
  
  //console.log(result);
  
  /*
  * splice()
  * 	- 可以用于删除数组中的指定元素
  * 	- 使用splice()会影响到原数组，会将指定元素从原数组中删除
  * 		并将被删除的元素作为返回值返回
  * 	- 参数：
  * 		第一个，表示开始位置的索引
  * 		第二个，表示删除的数量
  * 		第三个及以后。。
  * 			可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边
  * 	
  */
  
  arr = ["孙悟空","猪八戒","沙和尚","唐僧","白骨精"];
  var result = arr.splice(3,0,"牛魔王","铁扇公主","红孩儿");
  
  console.log(arr);
  //console.log(result);
  
  /*
  * concat()可以连接两个或多个数组，并将新的数组返回
  * 	- 该方法不会对原数组产生影响
  */
  var result = arr.concat(arr2,arr3,"牛魔王","铁扇公主");
  
  /*
  * join()
  * 	- 该方法可以将数组转换为一个字符串
  * 	- 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回
  * 	- 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
  * 		如果不指定连接符，则默认使用,作为连接符
  */
  arr = ["孙悟空","猪八戒","沙和尚","唐僧"];
  
  result = arr.join("@-@");
  /*
  * reverse()
  * 	- 该方法用来反转数组（前边的去后边，后边的去前边）
  * 	- 该方法会直接修改原数组
  */
  
  arr.reverse();
  
  //console.log(arr);
  
  arr = ["b","d","e","a","c"];
  
  /*
  * sort()
  * 	- 可以用来对数组中的元素进行排序
  * 	- 也会影响原数组，默认会按照Unicode编码进行排序
  */
  arr.sort();
  //arr.reverse();
  
  /*
  * 即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，
  * 	所以对数字进排序时，可能会得到错误的结果。
  * 
  * 我们可以自己来指定排序的规则
  * 	我们可以在sort()添加一个回调函数，来指定排序规则，
  * 		回调函数中需要定义两个形参,
  * 		浏览器将会分别使用数组中的元素作为实参去调用回调函数
  * 		使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边
  * 	- 浏览器会根据回调函数的返回值来决定元素的顺序，
  * 		如果返回一个大于0的值，则元素会交换位置
  * 		如果返回一个小于0的值，则元素位置不变
  * 		如果返回一个0，则认为两个元素相等，也不交换位置
  * 
  * 	- 如果需要升序排列，则返回 a-b
  * 		如果需要降序排列，则返回b-a
  */			
  ```

### 1.11 DOM

- 浏览器已经为我们提供 文档节点对象这个对象是window属性 ,可以在页面中直接使用，文档节点代表的是整个网页

- 浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行,如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载,会导致无法获取到DOM对象
- onload事件会在整个页面加载完成之后才触发 ,为window绑定一个onload事件 该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了
- DOM查询操作 略

- DOM增删改 略

  

### 1.12 事件

- 事件，就是用户和浏览器之间的交互行为， 比如：点击按钮，鼠标移动、关闭窗口。。。

- 事件对象 ：当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数

  ```
  areaDiv.onmousemove = function(event){
  			
      /*
      * 在IE8中，响应函数被处罚时，浏览器不会传递事件对象，
      * 	在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的
      */
      //解决事件对象的兼容性问题
      event = event || window.event;
  
      /*
      * clientX可以获取鼠标指针的水平坐标
      * cilentY可以获取鼠标指针的垂直坐标
      */
      var x = event.clientX;
      var y = event.clientY;
  
      //alert("x = "+x + " , y = "+y);
  
      //在showMsg中显示鼠标的坐标
      showMsg.innerHTML = "x = "+x + " , y = "+y;
  			
  };
  ```

- 事件的冒泡（Bubble）

  所谓的冒泡指的就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发

  在开发中大部分情况冒泡都是有用的,如果不希望发生事件冒泡可以通过事件对象来取消冒泡   event.cancelBubble = true;  设置为true，即可取消冒泡

- 事件的委派

  指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。

  事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

- 事件的绑定

  对象.事件 = 函数的形式绑定响应函数 它只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的

  addEventListener()  通过这个方法也可以为元素绑定响应函数 

  参数：1.事件的字符串，不要on  2.回调函数，当事件触发时该函数会被调用  3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false

  addEventListener()中的this，是绑定事件的对象

- 事件的传播 W3C综合了两个公司（微软和网景）的方案，将事件传播分成了三个阶段

1. 捕获阶段 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
2. 目标阶段 事件捕获到目标元素，捕获结束开始在目标元素上触发事件
3. 冒泡阶段 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件

如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true,一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false

### 1.13 BOM

- 浏览器对象模型

  BOM可以使我们通过JS来操作浏览器,在BOM中为我们提供了一组对象，用来完成对浏览器的操作

  BOM对象：

  Window ：  代表的是整个浏览器的窗口，同时window也是网页中的全局对象

  Navigator：代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器

  Location：代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面

  History：代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录

  Screen：代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

  这些BOM对象在浏览器中都是作为window对象的属性保存的，可以通过window对象来使用，也可以直接使用

- setInterval()  定时调用 

  可以将一个函数，每隔一段时间执行一次 

  参数： 1.回调函数，该函数会每隔一段时间被调用一次  2.每次调用间隔的时间，单位是毫秒

  返回值：返回一个Number类型的数据 这个数字用来作为定时器的唯一标识

  setTimeout() 延时调用，只执行一次 调用和setInterval()一样

### 1.14 JSON

- 将JSON字符串转换为JS中的对象, 在JS中，为我们提供了一个工具类，就叫JSON, 这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

  ```
  var json = '{"name":"孙悟空","age":18,"gender":"男"}';
  
  /*
  * json --> js对象
  * 	 JSON.parse()
  * 		- 可以将以JSON字符串转换为js对象
  * 		- 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回
  */
  
  var o = JSON.parse(json);
  var o2 = JSON.parse(arr);
  
  //console.log(o.gender);
  //console.log(o2[1]);
  
  var obj3 = {name:"猪八戒" , age:28 , gender:"男"};
  
  /*
  * JS对象 ---> JSON
  * 	JSON.stringify()
  * 		- 可以将一个JS对象转换为JSON字符串
  * 		- 需要一个js对象作为参数，会返回一个JSON字符串
  */
  
  var str = JSON.stringify(obj3);
  
  /*
  * eval()
  * 	- 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回
  * 	- 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块
  * 		如果不希望将其当成代码块解析，则需要在字符串前后各加一个()
  * 
  * 	- eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，
  * 		但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患
  */
  
  var str2 = "alert('hello');";
  
  var obj = eval("("+str+")");
  
  //console.log(obj);
  ```

### 1.15 线程机制和事件机制

- 浏览器内核组成

  -  html,css文档解析模块 : 负责页面文本的解析
  - dom/css模块 : 负责dom/css在内存中的相关处理
  - 布局和渲染模块 : 负责页面的布局和效果的绘制
  - 定时器模块 : 负责定时器的管理
  - 网络请求模块 : 负责服务器请求(常规/Ajax)
  - 事件响应模块 : 负责事件的管理

- JavaScript为什么时单线程的

  作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题

- 事件处理机制

  - 代码分类
    - 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
    - 回调执行代码: 处理回调逻辑

  - js引擎执行代码的基本流程: 初始化代码===>回调代码
  - 模型的2个重要组成部分: 事件管理模块 回调队列
  - 模型的运转流程
    - 执行初始化代码, 将事件回调函数交给对应模块管理
    - 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
    - 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行

## 2.  计算机网络基础

### 2.1 应用层

应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、 有哪些字段等等。

#### 2.1.1 HTTP协议

- 概况

  HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。

  HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。

  HTTP 有两种连接模式，一种是持续连接，一种非持续连接。非持续连接指的是服务器必须为每一个请求的对象建立和维护 一个全新的连接。持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。在 HTTP1.0 以前使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。HTTP1.1 以后默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持 同时建立 6 个持久连接。

- HTTP请求报文，格式如下：

```
GET / HTTP/1.1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这 个空行不能省略，它用来划分首部与实体。

请求行包含三个字段：方法字段、URL 字段和 HTTP 版本字段。

- HTTP响应报文：

```
HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

<html>
  <body>Hello World</body>
</html>
```

HTTP 响应报文的第一行叫做状态行，后面的行是首部行，最后是实体主体。

状态行包含了三个字段：协议版本字段、状态码和相应的状态信息。

实体部分是报文的主要部分，它包含了所请求的对象。

一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。

- 首部行

  首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。

  常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。

  常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。

  常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。

  常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修 改时间。

- HTTPS简介

  HTTPS 指的是超文本传输安全协议，HTTPS 是基于 HTTP 协议的，不过它会使用 TLS/SSL 来对数据加密。使用 TLS/ SSL 协议，所有的信息都是加密的，第三方没有办法窃听。并且它提供了一种校验机制，信息一旦被篡改，通信的双方会立刻发现。它还配备了身份证书，防止身份被冒充的情况出现。

  - #### TLS 握手过程

  1. 第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
  2. 第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
  3. 第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。
  4. 第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。
  5. 第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。

  - 实现原理、

    TLS 的握手过程主要用到了三个方法来保证传输的安全。

    首先是对称加密的方法，对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

    非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

    因此我们可以使用对称加密和非对称加密结合的方式，因为对称加密的方式的缺点是无法保证秘钥的安全传输，因此我们可以 非对称加密的方式来对对称加密的秘钥进行传输，然后以后的通信使用对称加密的方式来加密，这样就解决了两个方法各自存 在的问题。

    但是现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

    为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。

#### 2.1.2 DNS协议

- 概况

  DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。DNS 协议运行在 UDP 协议之上，使用 53 号 端口。

- DNS查询过程

  比如我们如果想要查询 [www.baidu.com](http://www.baidu.com/) 的 IP 地址，我们首先会将请求发送到本地的 DNS 服务器中，本地 DNS 服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

- DNS缓存

  DNS 缓存的原理非常简单，在一个请求链中，当某个 DNS 服务器接收到一个 DNS 回答后，它能够将回答中的信息缓存在本 地存储器中。返回的资源记录中的 TTL 代表了该条记录的缓存的时间。

- DNS实现负载均衡

  DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不 同的服务器上，这样来实现负载均衡。

### 2.2 传输层

传输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。

#### 2.2.1 UDP协议

UDP 是一种无连接的，不可靠的传输层协议。它只提供了传输层需要实现的最低限度的功能，除了复用/分解功能和少量的差错检测外，它几乎没有对IP增加其他的东西。UDP 协议适用于对实时性要求高的应用场景。

特点：

1. 使用 UDP 时，在发送报文段之前，通信双方没有握手的过程 。相对于 TCP 来说，没有建立连接的时延。因为没有连接，所以不需要在端系统中保存连接的状态。
2. UDP 提供尽力而为的交付服务，也就是说 UDP 协议不保证数据的可靠交付。
3. UDP 没有拥塞控制和流量控制的机制，所以 UDP 报文段的发送速率没有限制。
4. 因为一个 UDP 套接字只使用目的地址和目的端口来标识，所以 UDP 可以支持一对一、一对多、多对一和多对多的交互通信。
5. UDP 首部小，只有 8 个字节。

UDP报文段结构：

UDP 报文段由首部和应用数据组成。报文段首部包含四个字段，分别是源端口号、目的端口号、长度和检验和，每个字段的长度为两个字节。长度字段指的是整个报文段的长度，包含了首部和应用数据的大小。校验和是 UDP 提供的一种差错校验机制。 虽然提供了差错校验的机制，但是 UDP 对于差错的恢复无能为力。

![image-20210908142821273](.\images\image-20210908142821273.png)

#### 2.2.2 TCP协议

TCP协议师面向连接的，提供可靠的数据传输服务的

特点：

1. TCP 协议是面向连接的，在通信双方进行通信前，需要通过三次握手建立连接。它需要在端系统中维护双方连接的状态信息。
2. TCP 协议通过序号、确认号、定时重传、检验和等机制，来提供可靠的数据传输服务。
3. TCP 协议提供的是点对点的服务，即它是在单个发送方和单个接收方之间的连接。
4. TCP 协议提供的是全双工的服务，也就是说连接的双方的能够向对方发送和接收数据。
5. TCP 提供了拥塞控制机制，在网络拥塞的时候会控制发送数据的速率，有助于减少数据包的丢失和减轻网络中的拥塞程度。
6. TCP 提供了流量控制机制，保证了通信双方的发送和接收速率相同。如果接收方可接收的缓存很小时，发送方会降低发送 速率，避免因为缓存填满而造成的数据包的丢失。

TCP报文段结构：

TCP 报文段由首部和数据组成，它的首部一般为 20 个字节。

源端口和目的端口号用于报文段的多路复用和分解。

32 比特的序号和 32 比特的确认号，用与实现可靠数据运输服务。

16 比特的接收窗口字段用于实现流量控制，该字段表示接收方愿意接收的字节的数量。

4 比特的首部长度字段，该字段指示了以 32 比特的字为单位的 TCP 首部的长度。

6 比特的标志字段，ACK 字段用于指示确认序号的值是有效的，RST、SYN 和 FIN 比特用于连接建立和拆除。设置 PSH 字 段指示接收方应该立即将数据交给上层，URG 字段用来指示报文段里存在紧急的数据。

校验和提供了对数据的差错检测。

![image-20210908144756124](.\images\image-20210908144756124.png)

TCP三次握手的过程：

第一次握手，客户端向服务器发送一个 SYN 连接请求报文段，报文段的首部中 SYN 标志位置为 1，序号字段是一个任选的 随机数。它代表的是客户端数据的初始序号。

第二次握手，服务器端接收到客户端发送的 SYN 连接请求报文段后，服务器首先会为该连接分配 TCP 缓存和变量，然后向 客户端发送 SYN ACK 报文段，报文段的首部中 SYN 和 ACK 标志位都被置为 1，代表这是一个对 SYN 连接请求的确认， 同时序号字段是服务器端产生的一个任选的随机数，它代表的是服务器端数据的初始序号。确认号字段为客户端发送的序号加 一。

第三次握手，客户端接收到服务器的肯定应答后，它也会为这次 TCP 连接分配缓存和变量，同时向服务器端发送一个对服务器端的报文段的确认。第三次握手可以在报文段中携带数据。

在我看来，TCP三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。

TCP四次挥手的过程：

1. 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
2. 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
3. 服务器-关闭与客户端的连接，发送一个FIN给客户端
4. 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

#### 2.2.3 ARQ协议

ARQ 协议指的是自动重传请求，它通过超时和重传来保证数据的可靠交付，它是 TCP 协议实现可靠数据传输的一个很重要的机制。

它分为停止等待 ARQ 协议和连续 ARQ 协议。

一、停止等待 ARQ 协议

停止等待 ARQ 协议的基本原理是，对于发送方来说发送方每发送一个分组，就为这个分组设置一个定时器。当发送分组的确认 回答返回了，则清除定时器，发送下一个分组。如果在规定的时间内没有收到已发送分组的肯定回答，则重新发送上一个分组。

对于接受方来说，每次接受到一个分组，就返回对这个分组的肯定应答，当收到冗余的分组时，就直接丢弃，并返回一个对冗余 分组的确认。当收到分组损坏的情况的时候，直接丢弃。

使用停止等待 ARQ 协议的缺点是每次发送分组必须等到分组确认后才能发送下一个分组，这样会造成信道的利用率过低。

二、连续 ARQ 协议

连续 ARQ 协议是为了解决停止等待 ARQ 协议对于信道的利用率过低的问题。它通过连续发送一组分组，然后再等待对分组的 确认回答，对于如何处理分组中可能出现的差错恢复情况，一般可以使用滑动窗口协议和选择重传协议来实现。

1. 滑动窗口协议

使用滑动窗口协议，在发送方维持了一个发送窗口，发送窗口以前的分组是已经发送并确认了的分组，发送窗口中包含了已经发送但未确认的分组和允许发送但还未发送的分组，发送窗口以后的分组是缓存中还不允许发送的分组。当发送方向接收方发送分 组时，会依次发送窗口内的所有分组，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的分组。如果在定 时器的时间内收到某一个分组的确认回答，则滑动窗口，将窗口的首部移动到确认分组的后一个位置，此时如果还有已发送但没 有确认的分组，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送但还未收到确认的分组。

接收方使用的是累计确认的机制，对于所有按序到达的分组，接收方返回一个分组的肯定回答。如果收到了一个乱序的分组，那 么接方会直接丢弃，并返回一个最近的按序到达的分组的肯定回答。使用累计确认保证了确认号以前的分组都已经按序到达了， 所以发送窗口可以移动到已确认分组的后面。

滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况 的话，那么滑动窗口协议会重新发送所有的分组，这样就造成了大量不必要分组的丢弃和重传。

2. 选择重传协议

因为滑动窗口使用累计确认的方式，所以会造成很多不必要分组的重传。使用选择重传协议可以解决这个问题。

选择重传协议在发送方维护了一个发送窗口。发送窗口的以前是已经发送并确认的分组，窗口内包含了已发送但未被确认的分组， 已确认的乱序分组，和允许发送但还未发送的分组，发送窗口以后的是缓存中还不允许发送的分组。选择重传协议与滑动窗口协 议最大的不同是，发送方发送分组时，为一个分组都创建了一个定时器。当发送方接受到一个分组的确认应答后，取消该分组的 定时器，并判断接受该分组后，是否存在由窗口首部为首的连续的确认分组，如果有则向后移动窗口的位置，如果没有则将该分 组标识为已接收的乱序分组。当某一个分组定时器到时后，则重新传递这个分组。

在接收方，它会确认每一个正确接收的分组，不管这个分组是按序的还是乱序的，乱序的分组将被缓存下来，直到所有的乱序分 组都到达形成一个有序序列后，再将这一段分组交付给上层。对于不能被正确接收的分组，接收方直接忽略该分组。

#### 2.2.4 TCP的可靠运输机制

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### 2.2.5 TCP 的流量控制机制

TCP 提供了流量控制的服务，这个服务的主要目的是控制发送方的发送速率，保证接收方来得及接收。因为一旦发送的速率大于接收方所能接收的速率，就会造成报文段的丢失。接收方主要是通过接收窗口来告诉发送方自己所能接收的大小，发送方根据 接收方的接收窗口的大小来调整发送窗口的大小，以此来达到控制发送速率的目的。

#### 2.2.6 TCP 的拥塞控制机制

TCP 的拥塞控制主要是根据网络中的拥塞情况来控制发送方数据的发送速率，如果网络处于拥塞的状态，发送方就减小发送的速率，这样一方面是为了避免继续增加网络中的拥塞程度，另一方面也是为了避免网络拥塞可能造成的报文段丢失。

TCP 的拥塞控制主要使用了四个机制，分别是慢启动、拥塞避免、快速重传和快速恢复。

慢启动的基本思想是，因为在发送方刚开始发送数据的时候，并不知道网络中的拥塞程度，所以先以较低的速率发送，进行试探 ，每次收到一个确认报文，就将发动窗口的长度乘以2，这样每个 RTT (一个传输轮次所经历的时间其实就是往返时间RTT)时间后，发送窗口的长度就会加倍。当发送窗口的大小达 到一个阈值的时候就进入拥塞避免算法。

拥塞避免算法是为了避免可能发生的拥塞，将发送窗口的大小由每过一个 RTT 增长一倍，变为每过一个 RTT ，长度只加一。 这样将窗口的增长速率由指数增长，变为加法线性增长。

快速重传指的是，当发送方收到三个冗余的确认应答时，因为 TCP 使用的是累计确认的机制，所以很有可能是发生了报文段的 丢失，因此采用立即重传的机制，在定时器结束前发送所有已发送但还未接收到确认应答的报文段。

快速恢复是对快速重传的后续处理，因为网络中可能已经出现了拥塞情况，所以会将慢启动的阀值减小为原来的一半，然后将拥塞窗口的值置为减半后的阀值，然后开始执行拥塞避免算法，使得拥塞窗口缓慢地加性增大。简单来理解就是，乘性减，加性增。

TCP认为网络拥塞的主要依据是报文段的重传次数，它会根据网络中的拥塞程度，通过调整慢启动的阀值，然后交替使用上面四种机制来达到拥塞控制的目的。

### 2.3 网络层\数据链路层\物理层

网络层协议主要实现了不同主机间的逻辑通信功能。网络层协议一共包含两个主要的组件，一个 IP网际协议，一个是路由选择协议。

IP 网际协议规定了网络层的编址和转发方式，比如说我们接入网络的主机都会被分配一个 IP 地址，常用的比如 IPV4 使用 32 位来分配地址，还有 IPv6 使用 128 位来分配地址。

路由选择协议决定了数据报从源到目的地所流经的路径，常见的比如距离向量路由选择算法等。

数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点。每一台主机都有一个唯一的 MAC 地址， 这是由网络适配器决定的，在全世界都是独一无二的。

物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异，使数据链路层不需要考虑网络的具体传输介质是什么。

### 2.4 网络常见问题

- DNS为什么使用UDP协议作为传输层协议？

  ```
  DNS 使用UDP协议作为传输层协议的主要原因是为了避免使用TCP协议时造成的连接时延。因为为了得到一个域名的IP地址，往往会向多个域名服务器查询，如果使用TCP协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢，因为大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。
  ```
  
- post和get的区别？

  ```
  Post 和 Get 是 HTTP 请求的两种方法。
  （1）从应用场景上来说，GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。
  （2）因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
  （3）从发送的报文格式来说，Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
  （4）但是 Get 请求也可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。并且浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。还有就是 post 的参数传递支持更多的数据类型。
  ```
  
- 当你输入一个网址并按下回车之后发生了什么？

  ```
  （1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。
  
  （2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。
  
  （3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。
  
  （4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC地址作为源MAC地址，目的 MAC地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过ARP协议来获取网关的 MAC 地址，此时目的主机的MAC地址应该为网关的地址。
  
  （5）下面是TCP建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。
  
  （6）如果使用的是HTTPS协议，在通信前还存在 TLS的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的hash值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。
  
  （7）当页面请求发送到服务器端后，服务器端会返回一个html文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。
  
  （8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。
  
  （9）最后一步是 TCP 断开连接的四次挥手过程。
  ```
  
   简单点说：
  
  1. DNS解析
  2. TCP连接
  3. 发送HTTP请求
  4. 服务器处理请求并返回HTTP报文
  5. 浏览器解析渲染页面
  6. 连接结束
  
- 什么是正向代理和反向代理？

  ```
  我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。
  
  反向代理隐藏了真实的服务端，当我们请求一个网站的时候，背后可能有成千上万台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。
  ```

- 负载平衡的两种实现方式

  ```
  一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。
  
  另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。
  ```

- http协议版本特性及区别

  HTTP 0.9 -> HTTP 1.0 -> HTTP 1.1 -> HTTP 2

  - HTTP 0.9 是一个最古老的版本（最简单）
    - 只支持`GET`请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息
    - 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力
    - 服务端相响应之后，立即关闭TCP连接

  - HTTP 1.0 
    - 请求方式新增了POST，DELETE，PUT，HEADER等方式
    - 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息
    - 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输，根据Content-Type字段去解析，所以服务端返回的时候必须带着这个字段
    - 无状态：服务器不跟踪不记录请求过的状态 无状态的特性可以借助cookie/session机制来做身份认证和状态记录
    - 无连接：浏览器每次请求都需要建立tcp连接，可能会有如下缺陷
      - 无法复用连接 每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低
      - 队头阻塞 HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的

  - HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务

    - 长连接：新增Connection字段，可以设置keep-alive值保持连接不断开

    - 管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回

      请求1 --> 请求2 --> 请求3 > 响应1 --> 响应2 --> 响应3

      虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题

    - 缓存处理：新增字段cache-control

      当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存

    - 断点传输

      在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率

  - HTTP2

    - 二进制分帧

      HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率

    - 多路复用： 在共享TCP链接的基础上同时发送请求和响应

      在共享TCP链接的基础上同时发送请求和响应，基于二进制分帧，在同一域名下所有访问都是从同一个tcp连接中走，http消息被分解为独立的帧，乱序发送，服务端根据标识符和首部将消息重新组装起来。

    - 头部压缩

      由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP2可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源

  

- 各种协议与HTTP协议之间的关系

  ![image-20210908170123688](.\images\image-20210908170123688.png)

## 3. React基础知识汇总

### 1. react引用的必要操作

![image-20210923113700286](.\images\image-20210923113700286.png)

### 2. 虚拟DOM

1. 本质是Object类型的对象（一般对象）
2. 虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。
3. 虚拟DOM最终会被React转化为真实DOM，呈现在页面上。

```
const VDOM = (  /* 此处一定不要写引号，因为不是字符串 */
	<h1 id="title">
		<span>Hello,React</span>
	</h1>
)
//2.渲染虚拟DOM到页面
ReactDOM.render(VDOM,document.getElementById('test'))
```

### 3. jsx语法规则

1. 定义虚拟DOM时，不要写引号。
2. 标签中混入JS表达式时要用{}。
3. 样式的类名指定不要用class，要用className。
4. 内联样式，要用style={{key:value}}的形式去写。
5. 只有一个根标签
6. 标签必须闭合
7. 标签首字母
   - 若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
   - 若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。

```
<script type="text/babel" >
	const myId = 'aTgUiGu'
	const myData = 'HeLlo,rEaCt'

	//1.创建虚拟DOM
	const VDOM = (
		<div>
			<h2 className="title" id={myId.toLowerCase()}>
				<span style={{color:'white',fontSize:'29px'}}>{myData.toLowerCase()}					</span>
			</h2>
			<h2 className="title" id={myId.toUpperCase()}>
				<span style={{color:'white',fontSize:'29px'}}>{myData.toLowerCase()}					</span>
			</h2>
			<input type="text"/>
		</div>
	)
	//2.渲染虚拟DOM到页面
	ReactDOM.render(VDOM,document.getElementById('test'))

	</script>
```

### 4. 组件属性state

1.  state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)
2. 组件被称为"状态机", 通过更新组件的state来更新对应的页面显示(重新渲染组件)
3. 状态数据不可以直接进行修改，必须通过

## 4. CSS

### 4.1 CSS选择器

- id选择器  语法：#id属性值{}  例子：#box{} #red{}

- 类选择器  作用：根据元素的class属性值选中一组元素  语法：.class属性值

- 交集选择器  作用：选中同时复合多个条件的元素   语法：选择器1选择器2选择器3选择器n{}

- 选择器分组（并集选择器）   作用：同时选择多个选择器对应的元素   语法：选择器1,选择器2,选择器3,选择器n{}

- 子元素选择器 作用：选中指定父元素的指定子元素 语法：父元素 > 子元素  div.box > span

- 后代元素选择器 作用：选中指定元素内的指定后代元素  语法：祖先 后代

- 属性选择器：  [属性名] 选择含有指定属性的元素

- 伪类选择器： 伪类用来描述一个元素的特殊状态  比如：第一个子元素、被点击的元素、鼠标移入的元素...

  伪类一般情况下都是使用:开头 

  :first-child 第一个子元素 :last-child 最后一个子元素  

  :nth-child() 选中第n个子元素

  特殊值： n 第n个 n的范围0到正无穷  2n 或 even 表示选中偶数位的元素  2n+1 或 odd 表示选中奇数位的元素

- a元素的伪类 
  -  :link 用来表示没访问过的链接（正常的链接）
  - :visited 用来表示访问过的链接 由于隐私的原因，所以visited这个伪类只能修改链接的颜色
  - :hover 用来表示鼠标移入的状态
  - :active 用来表示鼠标点击
- 伪元素选择器： 伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置） 伪元素使用 :: 开头
  - ::first-letter 表示第一个字母
  - ::first-line 表示第一行
  - ::selection 表示选中的内容
  - ::before 元素的开始 
  - ::after 元素的最后  before 和 after 必须结合content属性来使用

- 选择器的权重

  



